---
layout: post
title: Pandas的数据结构
categories: [python]
description: 包括Dataframe, Series
keywords: python, pandas
catalog: true
multilingual: false
tags: python, pandas
---

## 前言
基本上, `Pandas`的`Series`沿袭了`Numpy`的设计, 是一维数组和数组的索引, 和`Numpy`不同的一点是这个一维数组可以是异构的,比如数字int和字符串混在一起, 这个时候数组的类型是`object`. 而`DataFrame`是为了处理表格和异构多维的数据.

### Series
可以用python的`list`初始化一个`Series`, 也可以用python的`Dict`初始化一个`Series`. 如果使用`Dict`那么序列的索引就是`Dict`的`Key`.
```python
>>> d = {'d': 1, 'e':2, 'a':0}
>>> pd.Series(d)
a    0
d    1
e    2
```
想要得到自己想要的顺序可以使用参数`index`排序`Series`, 下图的例子可以看到索引`b`, 但是它没有值会用`NaN`表示(可以使用`isnull`, `notnull`检测是否为空), 没有索引的值会被省略.
```python
>>> pd.Series(d, index=['e','b','d'])
e    2.0
b    NaN
d    1.0
dtype: float64
```
`Pandas`筛选比较强大的一点是直接可以在[]输入条件, 这点可能和python本身的语法有一点不同.
```python
>>> obj2= pd.Series(d)
>>> obj2
a    0
d    1
e    2
dtype: int64
>>> obj2 [ obj2 > 1]
e    2
dtype: int64
```
两个`Series`是可以直接通过索引直接做计算的, 类似数据库的`join`. 计算子必须都需要有相同的索引才会有计算结果, 否则会出现`NaN`.
```python
In [35]: obj3
Out[35]:
Ohio      35000
Oregon    16000
Texas     71000
Utah       5000
dtype: int64

In [36]: obj4
Out[36]:
California   NaN
Ohio         35000
Oregon       16000
Texas        71000
dtype: float64

In [37]: obj3 + obj4
Out[37]:
California    NaN
Ohio          70000.0
Oregon        32000.0
Texas         142000.0
Utah          NaN
dtype: float64
```
可以给`Series`起一个名字, 使用`Series.name`属性, 取个名字的好处是如果把`Series`放入`Dataframe`, 那么这个`name`就是`Dataframe`的列名.
```python
In [1]: s = pd.Series(["A","B","C"], name="foo")

In [2]: s
Out[2]: 
0    A
1    B
2    C
Name: foo, dtype: object

In [3]: pd.DataFrame(s)
Out[4]: 
  foo
0   A
1   B
2   C
```


### DataFrame
`Pandas`的`DataFrame`代表了一组表格(一般是二维, 可以使用`hierarchical indexing`来表示更高的维度数组), 数据的底层存储如下图所示, 数据会按类型分成不同的块存储实际的数据. 可以看到数据被没有指向具体的列, 而是通过`BlockManager`这个类是来管理实际数据到列名的映射.
![http://p0iombi30.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-16%20%E4%B8%8B%E5%8D%883.29.53.png](http://p0iombi30.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-16%20%E4%B8%8B%E5%8D%883.29.53.png)
有很多种方式构建`DataFrame`, 常见的一种是通过`Dict`,
```python
In [44]: data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'],
            'year': [2000, 2001, 2002, 2001, 2002, 2003],
            'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}
In [45]: frame = pd.DataFrame(data)
In [46]: frame
Out[46]:
   pop   state  year
0  1.5    Ohio  2000
1  1.7    Ohio  2001
2  3.6    Ohio  2002
3  2.4  Nevada  2001
4  2.9  Nevada  2002
5  3.2  Nevada  2003
```
`DataFrame`可以选择只要某几行, 也可以在`column`任意添加列名, 如何`column`这个字段赋予了不存在的列, 那么新加的这个列会显示`NaN`. 两者的区别是使用属性访问, 这个python属性必须符合python的规则.
```python
>>> pd.DataFrame(data, columns=['pop','jik'])
   pop  jik
0  1.5  NaN
1  1.7  NaN
2  3.6  NaN
3  2.4  NaN
4  2.9  NaN
5  3.2  NaN
```
想要取得`DataFrame`的某个列, 可以采用`.columnName`或切片的方式:
```python
In [51]: frame2['state']
Out[51]:
one        Ohio
two        Ohio
three      Ohio
four     Nevada
five     Nevada
six      Nevada
Name: state, dtype: object

In [52]: frame2.year
Out[52]:
one      2000
two      2001
three    2002
four     2001
five     2002
six      2003
Name: year, dtype: int64
```
通过`DataFrame.loc[]`可以选取某几行, 这个`loc`用的是[] ,而不是(), 和python的语法又有些区别. 一般使用`loc[]`定位字符串索引, `iloc[]`定位数字索引.
```python
>>> frame.iloc[3]
pop         2.4
state    Nevada
year       2001
Name: 3, dtype: object
```