---
layout: post
title: MongoDB的架构
categories: [db]
description: 主要区别于RDBMS
keywords: mongo, database
catalog: true
multilingual: false
tags: mongo
---

## 前言
最近尝试用MongoDB替换Mysql， 由于Mysql的写能力限制， 32C128G的实例同时写入1M的数据CPU飙升， 更不用说如果是并发的情况。如下图所示(v3.2): 
![http://p0iombi30.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8A%E5%8D%8811.19.05.png](http://p0iombi30.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-24%20%E4%B8%8A%E5%8D%8811.19.05.png)

### 与RBDMS的主要区别
MongoDB和RDBMS的主要区别在于：
- RBDMS的数据记录是`平`， 而MongoDB的数据单元`Document`是可以嵌入的，比如一个CSV文件， 一个字段是一个值， 但是mongo可以使用Bson, 一个字段可以存储多个值`{'key': [v1,v2]}`.通过组合还可以生成更多复杂的数据结构。
- RBDMS所有的数据结构`schema`必须预定义， 而`Document`可以存储任何结构的数据。
- MongoDB是没有`join`查询操作的。 RBDMS数据库设计的核心讲究`Normalization`, 数据越结构化，冗余越少越好。 而MongoDB鼓励`denormalized`, 通过数据冗余做到`join`查询。
- MongoDB的数据一致性需要客户端来维护， mongo没有`ACID`的`Isolation`概念， 一个并发客户端可能读到另一个并发用户修改数据。
- `transaction`事务也是不存在，（**注意， 4.0这个版本支持ACID的事务**）。原子性操作只能做到document级别。
而正是移除关系型数据库一部分特性， mongo才能做到更加可扩展和轻量级， 这两条正适合处理大数据。

### 查询处理
mongo的`Collection`可以认为是关系型数据库的`table`， `Document`可以认为是关系型数据库的`records`. 如下是一些基本操作, 不需要预创建数据库和`collection`
```python
In [1]: import pymongo

In [2]: p = {'first':"Dave", 'lastname': "He"}

In [3]: client = pymongo.MongoClient()

In [4]: db = client.test_database

In [6]: db.person.insert_one({'first':'NN', 'lastname':'HE'})
Out[6]: <pymongo.results.InsertOneResult at 0x21f9710>

In [7]: db.person.find_one()
Out[7]: 
{u'_id': ObjectId('5ba858bc91046605e83667dd'),
 u'first': u'Dave',
 u'lastname': u'He'}
```
可以创建索引加速查询, MongoDB的索引以`Btree`的数据结构存储, 所以支持范围查询.
```python
In [5]: db.person.index_information()
Out[5]: {u'_id_': {u'key': [(u'_id', 1)], u'ns': u'test_database.person', u'v': 2}}
```
mongo默认给`_id`创建索引, 也可以给一个字段建新的索引, 创建索引可以是前台线下模式或者后台在线模式, 如果是线下模式, 需要考虑如果是多副本集, 那么这些副本索引需要做到滚动更新.
```python
In [6]: r = db.person.create_index([('lastname', pymongo.ASCENDING)], unique=True)

In [8]: db.person.index_information()
Out[8]: 
{u'_id_': {u'key': [(u'_id', 1)], u'ns': u'test_database.person', u'v': 2},
 u'lastname_1': {u'key': [(u'lastname', 1)],
  u'ns': u'test_database.person',
  u'unique': True,
  u'v': 2}}
```
索引创建完, 那么一个`collection`的多索引是如何配合查询的呢? 当一个查询执行时, mongo会给每个索引创建一个执行计划, 每个索引轮流执行查询, 直到所有索引执行完查询, mongo记录下最快执行查询的索引, 后续就会使用这个索引查询, 直到后续一定量的数据更新, 才会重新执行上诉流程.
如果是多条件查询, mongo会优先匹配单个最佳索引, 然后对后续的条件迭代查询.
